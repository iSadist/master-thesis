function [edge_magnitude, edge_orientation] = coloredges(im)
%COLOREDGES Edges of a color image by the max gradient method.
%   [MAGNITUDE, ORIENTATION] = COLOREDGES(IMAGE)
%   Extracts the edges of a color image without converting it to grayscale.
%
%   Changes in color are detected even when the grayscale color of two
%   pixels are the same. The edge strength is typically greater or equal to
%   the magnitude obtained by simply filtering a grayscale image.
%
%   Optionally, the edge orientation can also be returned.
%
%   Example
%   -------
%   The image generated by the example code shows two edge types:
%     White - edges found by both methods.
%     Red - edges found only by the color method.
%
%   This clearly shows that a significant amount of information is lost by
%   the standard method, but it is recovered with the gradient method.
%
%     figure, im = imread('peppers.png'); imshow(im)
%
%     %get color edges and normalize magnitude
%     C = coloredges(im);
%     C = C / max(C(:));
%
%     %get grayscale edges and normalize magnitude
%     G_image = single(rgb2gray(im)) / 255;
%     G = sqrt(imfilter(G_image, fspecial('sobel')').^2 + imfilter(G_image, fspecial('sobel')).^2);
%     G = G / max(G(:));
%
%     %show comparison
%     figure, imshow(uint8(255 * cat(3, C, G, G)))
%
%   Algorithm
%   ---------
%   The RGB color of each pixel is treated as a 3D vector, and the strength
%   of the edge is the magnitude of the maximum gradient. This also works
%   if the image is in any other (3-dimensional) color space. Direct
%   formulas for the jacobian eigenvalues were used, so this function is
%   vectorized and yields good results without sacrificing performance.
%
%   Author: Joo F. Henriques
%

	%J is the jacobian, its elements are the partial derivatives of r/g/b
	%with respect to x/y. the edge strength is the greatest eigenvalue of:
	% J'*J
	% =
	% [ rx,  gx,  bx ] * [ rx,  ry ]
	% [ ry,  gy,  by ]   [ gx,  gy ]
	% 	                 [ bx,  by ]
	% =
	% [ rx^2 + gx^2 + bx^2,   rx*ry + gx*gy + bx*by ]
	% [ rx*ry + gx*gy + bx*by,   ry^2 + gy^2 + by^2 ]
	% =
	% [ Jx, Jxy ]
	% [ Jxy, Jy ]
	
	%smoothed partial derivatives using sobel filter (could use any other)
	im = single(im) / 255;
	yfilter = fspecial('prewitt');
	xfilter = yfilter';
	
	rx = imfilter(im(:,:,1), xfilter);
	gx = imfilter(im(:,:,2), xfilter);
	bx = imfilter(im(:,:,3), xfilter);
	
	ry = imfilter(im(:,:,1), yfilter);
	gy = imfilter(im(:,:,2), yfilter);
	by = imfilter(im(:,:,3), yfilter);
	
	Jx = rx.^2 + gx.^2 + bx.^2;
	Jy = ry.^2 + gy.^2 + by.^2;
	Jxy = rx.*ry + gx.*gy + bx.*by;
	
	%compute first (greatest) eigenvalue of 2x2 matrix J'*J.
	%note that the abs() is only needed because some values may be slightly
	%negative due to round-off error.
	D = sqrt(abs(Jx.^2 - 2*Jx.*Jy + Jy.^2 + 4*Jxy.^2));
	e1 = (Jx + Jy + D) / 2;
	%the 2nd eigenvalue would be:  e2 = (Jx + Jy - D) / 2;

	edge_magnitude = sqrt(e1);
	
	if nargout > 1,
		%compute edge orientation (from eigenvector tangent)
		edge_orientation = atan2(-Jxy, e1 - Jy);
	end

end
