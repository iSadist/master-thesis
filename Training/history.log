Model History:

[
	Epochs: 100
	Batch Size: 476
	Training share: 75%

	Training Accuracy: 89.08%
	Evaluation Accuracy: 96.85%

	Test Accuracy: 48%

	model = keras.Sequential([
			keras.layers.Conv2D(8, kernel_size=(8, 8), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
			keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
			keras.layers.Conv2D(8, kernel_size=(6,6), strides=(2, 2)),
			keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
			keras.layers.Conv2D(8, kernel_size=(4,4), strides=(2, 2)),
			keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
			keras.layers.Flatten(),
		    keras.layers.Dense(16, activation=tf.nn.relu),
		    keras.layers.Dropout(0.1),
		    keras.layers.Dense(16, activation=tf.nn.relu),
		    keras.layers.Dropout(0.1),
		    keras.layers.Dense(16, activation=tf.nn.relu),
		    keras.layers.Dropout(0.1),
		    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
		])

		model.compile(optimizer=keras.optimizers.Adam(),
		              loss='sparse_categorical_crossentropy',
		              metrics=['accuracy'])

]

[
	Epochs: 65
	Batch Size: 476
	Training share: 75%

	Training Accuracy: 78.05%
	Evaluation Accuracy: 86.66%

	Test Accuracy: 41%

	model = keras.Sequential([
			keras.layers.Conv2D(8, kernel_size=(8, 8), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
			keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
			keras.layers.Conv2D(8, kernel_size=(6,6), strides=(2, 2)),
			keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
			keras.layers.Conv2D(8, kernel_size=(4,4), strides=(2, 2)),
			keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
			keras.layers.Flatten(),
		    keras.layers.Dense(16, activation=tf.nn.relu),
		    keras.layers.Dropout(0.1),
		    keras.layers.Dense(16, activation=tf.nn.relu),
		    keras.layers.Dropout(0.1),
		    keras.layers.Dense(16, activation=tf.nn.relu),
		    keras.layers.Dropout(0.1),
		    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
		])

		model.compile(optimizer=keras.optimizers.Adam(),
		              loss='sparse_categorical_crossentropy',
		              metrics=['accuracy'])

]

[
	Epochs: 50
	Batch Size: 476
	Training share: 75%

	Training Accuracy: 95.80%
	Evaluation Accuracy: 98.95%

	Test Accuracy: 53%

	model = keras.Sequential([
		keras.layers.Conv2D(16, kernel_size=(10, 10), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Conv2D(16, kernel_size=(8,8), strides=(2, 2)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Flatten(),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])

	model.compile(optimizer=keras.optimizers.Adam(),
	              loss='sparse_categorical_crossentropy',
	              metrics=['accuracy'])
]

[
	Epochs: 50
	Batch Size: 476
	Training share: 75%

	Training Accuracy: 87.55%
	Evaluation Accuracy: 94.54%

	Test Accuracy: 58%

	model = keras.Sequential([
		keras.layers.Conv2D(16, kernel_size=(10, 10), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Conv2D(16, kernel_size=(8,8), strides=(2, 2)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Flatten(),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])

	model.compile(optimizer=keras.optimizers.Adam(),
	              loss='sparse_categorical_crossentropy',
	              metrics=['accuracy'])
]

[
	Epochs: 100
	Batch Size: 476
	Training share: 75%

	Training Accuracy: 93.88%
	Evaluation Accuracy: 98.42%

	Test Accuracy: 48.2%

	model = keras.Sequential([
		keras.layers.Conv2D(16, kernel_size=(10, 10), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Conv2D(16, kernel_size=(8,8), strides=(2, 2)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Flatten(),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.2),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.2),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])

	model.compile(optimizer=keras.optimizers.Adam(),
	              loss='sparse_categorical_crossentropy',
	              metrics=['accuracy'])
]

[
	Epochs: 100
	Batch Size: 476
	Training share: 75%

	Training Accuracy: 93.70%
	Evaluation Accuracy: 98.11%

	Test Accuracy: 55.5%

	model = keras.Sequential([
		keras.layers.Conv2D(16, kernel_size=(10, 10), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.1),
		keras.layers.Conv2D(16, kernel_size=(8,8), strides=(2, 2)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.1),
		keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Flatten(),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])

	model.compile(optimizer=keras.optimizers.Adam(),
	              loss='sparse_categorical_crossentropy',
	              metrics=['accuracy'])
]

[
	Epochs: 60
	Batch Size: 476
	Training share: 75%

	Training Accuracy: 85.61%
	Evaluation Accuracy: 92.02%

	Test Accuracy: 45.35%

	model = keras.Sequential([
		keras.layers.Conv2D(16, kernel_size=(10, 10), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.1),
		keras.layers.Conv2D(16, kernel_size=(8,8), strides=(2, 2)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.1),
		keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Flatten(),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])

	model.compile(optimizer=keras.optimizers.Adam(),
	              loss='sparse_categorical_crossentropy',
	              metrics=['accuracy'])
]

[
	Epochs: 100
	Batch Size: 476
	Training share: 75%

	Training Accuracy: 92.50%
	Evaluation Accuracy: 98.63%

	Test Accuracy: 60.01%

	model = keras.Sequential([
		keras.layers.Conv2D(16, kernel_size=(10, 10), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.2),
		keras.layers.Conv2D(16, kernel_size=(8,8), strides=(2, 2)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.2),
		keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Flatten(),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])

	model.compile(optimizer=keras.optimizers.Adam(),
	              loss='sparse_categorical_crossentropy',
	              metrics=['accuracy'])
]

[
	Epochs: 100
	Batch Size: 476
	Training share: 90%
	Validation share: 50%

	Training Accuracy: 74.20%
	Evaluation Accuracy: 84.90%

	Test Accuracy: 59.87%

	model = keras.Sequential([
		keras.layers.Conv2D(16, kernel_size=(10, 10), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.2),
		keras.layers.Conv2D(16, kernel_size=(8,8), strides=(2, 2)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.2),
		keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Flatten(),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])

	model.compile(optimizer=keras.optimizers.Adam(),
	              loss='sparse_categorical_crossentropy',
	              metrics=['accuracy'])
]

[
	Epochs: 100
	Batch Size: 300
	Training share: 75%

	Training Accuracy: 91%
	Evaluation Accuracy: ?

	Test Accuracy: 59%
	model = keras.Sequential([
	  keras.layers.Conv2D(16, kernel_size=(4, 4), strides=(1, 1), input_shape=(image_height, image_width, number_of_color_channels)),
	  keras.layers.MaxPool2D(pool_size=(4,4), padding="valid"),
	  keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
	  keras.layers.MaxPool2D(pool_size=(4, 4), padding="valid"),
	  keras.layers.Conv2D(16, kernel_size=(2,2), strides=(1, 1)),
	  keras.layers.MaxPool2D(pool_size=(4, 4), padding="valid"),
	  keras.layers.Flatten(),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])
	model.compile(optimizer=keras.optimizers.Adam(),
								loss='sparse_categorical_crossentropy',
								metrics=['accuracy'])
]

[
	Epochs: 65
	Batch Size: 476
	Training share: 75%
	Validation share: 25%%

	Training Accuracy: 85.27%
	Evaluation Accuracy: 89.29%

	Test Accuracy: 41.25%

		keras.layers.Conv2D(8, kernel_size=(9, 9), strides=(1, 1), input_shape=(image_height, image_width, number_of_color_channels)),
		keras.layers.MaxPool2D(pool_size=(4, 4), padding="valid"),
		keras.layers.Conv2D(8, kernel_size=(6,6), strides=(1, 1)),
		keras.layers.MaxPool2D(pool_size=(4, 4), padding="valid"),
		keras.layers.Conv2D(8, kernel_size=(4,4), strides=(1, 1)),
		keras.layers.Flatten(),
		keras.layers.Dense(32, activation=tf.nn.relu),
		keras.layers.Dropout(0.1),
		keras.layers.Dense(32, activation=tf.nn.relu),
		keras.layers.Dropout(0.1),
		keras.layers.Dense(16, activation=tf.nn.relu),
		keras.layers.Dropout(0.1),
		keras.layers.Dense(16, activation=tf.nn.relu),
		keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])
	model.compile(optimizer=keras.optimizers.Adam(),
								loss='sparse_categorical_crossentropy',
								metrics=['accuracy'])
]

[
	Epochs: 150
	Batch Size: 476
	Training share: 90%
	Validation share: 50%%

	Training Accuracy: 91.39%
	Evaluation Accuracy: 95.72%

	Test Accuracy: 69.12%

	model = keras.Sequential([
		keras.layers.Conv2D(16, kernel_size=(10, 10), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.2),
		keras.layers.Conv2D(16, kernel_size=(8,8), strides=(2, 2)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.2),
		keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.2),
		keras.layers.Flatten(),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])

	model.compile(optimizer=keras.optimizers.Adam(),
	              loss='sparse_categorical_crossentropy',
	              metrics=['accuracy'])
]


[
Epochs: 100
Batch Size: 476
Training share: 75%
Validation share: 50%

Training Accuracy: 97.06%
Evaluation Accuracy: 99.89%

Test Accuracy: 72.45%

model = keras.Sequential([
	keras.layers.Conv2D(16, kernel_size=(10, 10), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
	keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
	keras.layers.Dropout(0.2),
	keras.layers.Conv2D(16, kernel_size=(8,8), strides=(2, 2)),
	keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
	keras.layers.Dropout(0.2),
	keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
	keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
	keras.layers.Dropout(0.2),
	keras.layers.Flatten(),
		keras.layers.Dense(32, activation=tf.nn.relu),
		keras.layers.Dropout(0.1),
		keras.layers.Dense(32, activation=tf.nn.relu),
		keras.layers.Dropout(0.1),
		keras.layers.Dense(16, activation=tf.nn.relu),
		keras.layers.Dropout(0.1),
		keras.layers.Dense(16, activation=tf.nn.relu),
		keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
])

model.compile(optimizer=keras.optimizers.Adam(),
							loss='sparse_categorical_crossentropy',
							metrics=['accuracy'])
]


[
	Epochs: 100
	Batch Size: 476
	Training share: 75%
	Validation share: 50%

	Training Accuracy: 99.74%
	Evaluation Accuracy: 98.58%

	Test Accuracy: 63.40%
	model = keras.Sequential([
		keras.layers.Conv2D(16, kernel_size=(10, 10), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
		keras.layers.BatchNormalization(),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Conv2D(16, kernel_size=(8,8), strides=(2, 2)),
		keras.layers.BatchNormalization(),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
		keras.layers.BatchNormalization(),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Flatten(),
			keras.layers.Dense(32, activation=tf.nn.relu),
			keras.layers.Dropout(0.1),
			keras.layers.Dense(32, activation=tf.nn.relu),
			keras.layers.Dropout(0.1),
			keras.layers.Dense(16, activation=tf.nn.relu),
			keras.layers.Dropout(0.1),
			keras.layers.Dense(16, activation=tf.nn.relu),
			keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])

	model.compile(optimizer=keras.optimizers.Adam(),
								loss='sparse_categorical_crossentropy',
								metrics=['accuracy'])
]

[
	Epochs: 150
	Batch Size: 476
	Training share: 90%
	Validation share: 50%

	Training Accuracy: 96.56%
	Evaluation Accuracy: 99.52%

	Test Accuracy: 78.36%
	model = keras.Sequential([
		keras.layers.Conv2D(16, kernel_size=(10, 10), strides=(2, 2), input_shape=(image_height, image_width, number_of_color_channels)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.2),
		keras.layers.Conv2D(16, kernel_size=(8,8), strides=(2, 2)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.2),
		keras.layers.Conv2D(16, kernel_size=(4,4), strides=(1, 1)),
		keras.layers.MaxPool2D(pool_size=(2, 2), padding="valid"),
		keras.layers.Dropout(0.2),
		keras.layers.Flatten(),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.2),
	    keras.layers.Dense(32, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dropout(0.1),
	    keras.layers.Dense(16, activation=tf.nn.relu),
	    keras.layers.Dense(4, activation=tf.nn.softmax) # The number of nodes must be the same as the number of possibilities
	])

	model.compile(optimizer=keras.optimizers.Adam(),
	              loss='sparse_categorical_crossentropy',
	              metrics=['accuracy'])
]
